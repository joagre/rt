#include "acrt_runtime.h"
#include "acrt_link.h"
#include "acrt_ipc.h"
#include "acrt_timer.h"
#include <stdio.h>
#include <string.h>

// Test results
static int tests_passed = 0;
static int tests_failed = 0;

#define TEST_PASS(name) do { printf("  ✓ PASS: %s\n", name); tests_passed++; } while(0)
#define TEST_FAIL(name) do { printf("  ✗ FAIL: %s\n", name); tests_failed++; } while(0)

// ============================================================================
// Test 1: Higher priority actors run before lower priority ones
// ============================================================================

// Shared execution order tracking
#define MAX_EXEC_ORDER 16
static int g_exec_order[MAX_EXEC_ORDER];
static int g_exec_count = 0;

static void priority_actor(void *arg) {
    int id = *(int *)arg;

    // Record execution order
    if (g_exec_count < MAX_EXEC_ORDER) {
        g_exec_order[g_exec_count++] = id;
    }

    acrt_exit();
}

static void test1_coordinator(void *arg) {
    (void)arg;
    printf("\nTest 1: Higher priority runs first\n");

    g_exec_count = 0;

    // Actor IDs encode priority: 0=CRITICAL, 1=HIGH, 2=NORMAL, 3=LOW
    static int ids[4] = {3, 2, 1, 0};  // Spawn in reverse order (LOW first)

    // Spawn LOW priority first
    actor_config cfg = ACRT_ACTOR_CONFIG_DEFAULT;
    cfg.priority = ACRT_PRIO_LOW;
    acrt_spawn_ex(priority_actor, &ids[0], &cfg);

    // Spawn NORMAL priority
    cfg.priority = ACRT_PRIO_NORMAL;
    acrt_spawn_ex(priority_actor, &ids[1], &cfg);

    // Spawn HIGH priority
    cfg.priority = ACRT_PRIO_HIGH;
    acrt_spawn_ex(priority_actor, &ids[2], &cfg);

    // Spawn CRITICAL priority
    cfg.priority = ACRT_PRIO_CRITICAL;
    acrt_spawn_ex(priority_actor, &ids[3], &cfg);

    // Yield to let them all run
    // Since we're NORMAL priority, CRITICAL and HIGH should run before us
    acrt_yield();

    // Give time for all to complete
    timer_id timer;
    acrt_timer_after(50000, &timer);  // 50ms
    acrt_message msg;
    acrt_ipc_recv(&msg, -1);

    // Check execution order: should be CRITICAL(0), HIGH(1), NORMAL(2), LOW(3)
    // But coordinator is also NORMAL, so order depends on round-robin
    // The key check: CRITICAL and HIGH must come before NORMAL and LOW

    bool critical_before_normal = false;
    bool high_before_low = false;
    int critical_pos = -1, high_pos = -1, normal_pos = -1, low_pos = -1;

    for (int i = 0; i < g_exec_count; i++) {
        if (g_exec_order[i] == 0) critical_pos = i;
        if (g_exec_order[i] == 1) high_pos = i;
        if (g_exec_order[i] == 2) normal_pos = i;
        if (g_exec_order[i] == 3) low_pos = i;
    }

    printf("  Execution order: ");
    for (int i = 0; i < g_exec_count; i++) {
        const char *names[] = {"CRITICAL", "HIGH", "NORMAL", "LOW"};
        printf("%s ", names[g_exec_order[i]]);
    }
    printf("\n");

    if (critical_pos >= 0 && normal_pos >= 0) {
        critical_before_normal = (critical_pos < normal_pos);
    }
    if (high_pos >= 0 && low_pos >= 0) {
        high_before_low = (high_pos < low_pos);
    }

    if (critical_before_normal && high_before_low) {
        TEST_PASS("higher priority actors run before lower priority");
    } else {
        TEST_FAIL("priority ordering violated");
        printf("    critical_pos=%d, high_pos=%d, normal_pos=%d, low_pos=%d\n",
               critical_pos, high_pos, normal_pos, low_pos);
    }

    acrt_exit();
}

// ============================================================================
// Test 2: Round-robin within same priority level
// ============================================================================

static int g_rr_order[8];
static int g_rr_count = 0;

static void rr_actor(void *arg) {
    int id = *(int *)arg;

    // Record first execution
    if (g_rr_count < 8) {
        g_rr_order[g_rr_count++] = id;
    }

    // Yield and run again to test round-robin
    acrt_yield();

    if (g_rr_count < 8) {
        g_rr_order[g_rr_count++] = id;
    }

    acrt_exit();
}

static void test2_coordinator(void *arg) {
    (void)arg;
    printf("\nTest 2: Round-robin within same priority\n");

    g_rr_count = 0;

    // Spawn 3 actors at NORMAL priority
    static int ids[3] = {1, 2, 3};
    actor_config cfg = ACRT_ACTOR_CONFIG_DEFAULT;
    cfg.priority = ACRT_PRIO_NORMAL;

    for (int i = 0; i < 3; i++) {
        acrt_spawn_ex(rr_actor, &ids[i], &cfg);
    }

    // Wait for them to complete
    timer_id timer;
    acrt_timer_after(100000, &timer);  // 100ms
    acrt_message msg;
    acrt_ipc_recv(&msg, -1);

    printf("  Execution sequence: ");
    for (int i = 0; i < g_rr_count; i++) {
        printf("%d ", g_rr_order[i]);
    }
    printf("\n");

    // Check that actors alternate (round-robin behavior)
    // First pass: 1, 2, 3 (or some permutation)
    // Second pass: same permutation again
    // The key is that one actor doesn't monopolize

    bool has_interleaving = false;
    for (int i = 1; i < g_rr_count; i++) {
        if (g_rr_order[i] != g_rr_order[i-1]) {
            has_interleaving = true;
            break;
        }
    }

    if (has_interleaving && g_rr_count >= 6) {
        TEST_PASS("round-robin scheduling within priority level");
    } else if (g_rr_count >= 6) {
        TEST_FAIL("no interleaving detected");
    } else {
        TEST_FAIL("not enough executions recorded");
    }

    acrt_exit();
}

// ============================================================================
// Test 3: High priority actor runs immediately after becoming ready
// ============================================================================

static bool g_high_ran_first = false;
static bool g_low_finished = false;

static void high_prio_late_spawn(void *arg) {
    (void)arg;
    // This high-priority actor was spawned by the low-priority one
    // It should run before the low-priority actor continues
    if (!g_low_finished) {
        g_high_ran_first = true;
    }
    acrt_exit();
}

static void low_prio_spawner(void *arg) {
    (void)arg;

    // Spawn a high-priority actor
    actor_config cfg = ACRT_ACTOR_CONFIG_DEFAULT;
    cfg.priority = ACRT_PRIO_HIGH;
    acrt_spawn_ex(high_prio_late_spawn, NULL, &cfg);

    // Yield - high priority should run now
    acrt_yield();

    g_low_finished = true;
    acrt_exit();
}

static void test3_coordinator(void *arg) {
    (void)arg;
    printf("\nTest 3: High priority preempts after yield\n");

    g_high_ran_first = false;
    g_low_finished = false;

    // Spawn a LOW priority actor that will spawn a HIGH priority actor
    actor_config cfg = ACRT_ACTOR_CONFIG_DEFAULT;
    cfg.priority = ACRT_PRIO_LOW;
    acrt_spawn_ex(low_prio_spawner, NULL, &cfg);

    // Wait for completion
    timer_id timer;
    acrt_timer_after(100000, &timer);
    acrt_message msg;
    acrt_ipc_recv(&msg, -1);

    if (g_high_ran_first) {
        TEST_PASS("high priority actor runs before low priority continues");
    } else {
        TEST_FAIL("high priority actor did not preempt");
    }

    acrt_exit();
}

// ============================================================================
// Test 4: All priority levels eventually run (no starvation)
// ============================================================================

static bool g_prio_ran[4] = {false, false, false, false};

static void starvation_actor(void *arg) {
    int prio = *(int *)arg;
    g_prio_ran[prio] = true;
    acrt_exit();
}

static void test4_coordinator(void *arg) {
    (void)arg;
    printf("\nTest 4: No starvation (all priorities run)\n");

    memset(g_prio_ran, 0, sizeof(g_prio_ran));

    // Spawn one actor at each priority level
    static int prios[4] = {0, 1, 2, 3};

    for (int i = 0; i < 4; i++) {
        actor_config cfg = ACRT_ACTOR_CONFIG_DEFAULT;
        cfg.priority = (acrt_priority)i;
        acrt_spawn_ex(starvation_actor, &prios[i], &cfg);
    }

    // Wait for all to complete
    timer_id timer;
    acrt_timer_after(100000, &timer);
    acrt_message msg;
    acrt_ipc_recv(&msg, -1);

    bool all_ran = g_prio_ran[0] && g_prio_ran[1] && g_prio_ran[2] && g_prio_ran[3];

    printf("  CRITICAL ran: %s\n", g_prio_ran[0] ? "yes" : "no");
    printf("  HIGH ran: %s\n", g_prio_ran[1] ? "yes" : "no");
    printf("  NORMAL ran: %s\n", g_prio_ran[2] ? "yes" : "no");
    printf("  LOW ran: %s\n", g_prio_ran[3] ? "yes" : "no");

    if (all_ran) {
        TEST_PASS("all priority levels eventually execute");
    } else {
        TEST_FAIL("some priority levels starved");
    }

    acrt_exit();
}

// ============================================================================
// Test 5: Default priority is NORMAL
// ============================================================================

static acrt_priority g_default_prio = ACRT_PRIO_COUNT;

static void check_default_prio(void *arg) {
    (void)arg;
    // We need to check the actor's priority - but we don't have direct access
    // We'll verify by checking ACRT_ACTOR_CONFIG_DEFAULT
    actor_config cfg = ACRT_ACTOR_CONFIG_DEFAULT;
    g_default_prio = cfg.priority;
    acrt_exit();
}

static void test5_coordinator(void *arg) {
    (void)arg;
    printf("\nTest 5: Default priority is NORMAL\n");

    // Check ACRT_ACTOR_CONFIG_DEFAULT directly
    actor_config cfg = ACRT_ACTOR_CONFIG_DEFAULT;

    if (cfg.priority == ACRT_PRIO_NORMAL) {
        TEST_PASS("ACRT_ACTOR_CONFIG_DEFAULT has NORMAL priority");
    } else {
        TEST_FAIL("default priority is not NORMAL");
        printf("    default priority = %d (expected %d)\n", cfg.priority, ACRT_PRIO_NORMAL);
    }

    // Also spawn an actor with default config to verify
    acrt_spawn(check_default_prio, NULL);

    timer_id timer;
    acrt_timer_after(50000, &timer);
    acrt_message msg;
    acrt_ipc_recv(&msg, -1);

    acrt_exit();
}

// ============================================================================
// Test runner
// ============================================================================

static void (*test_funcs[])(void *) = {
    test1_coordinator,
    test2_coordinator,
    test3_coordinator,
    test4_coordinator,
    test5_coordinator,
};

#define NUM_TESTS (sizeof(test_funcs) / sizeof(test_funcs[0]))

static void run_all_tests(void *arg) {
    (void)arg;

    for (size_t i = 0; i < NUM_TESTS; i++) {
        actor_config cfg = ACRT_ACTOR_CONFIG_DEFAULT;
        cfg.stack_size = 64 * 1024;

        actor_id test = acrt_spawn_ex(test_funcs[i], NULL, &cfg);
        if (test == ACTOR_ID_INVALID) {
            printf("Failed to spawn test %zu\n", i);
            continue;
        }

        // Link to test actor so we know when it finishes
        acrt_link(test);

        // Wait for test to finish
        acrt_message msg;
        acrt_ipc_recv(&msg, 5000);
    }

    acrt_exit();
}

int main(void) {
    printf("=== Priority Scheduling Test Suite ===\n");

    acrt_status status = acrt_init();
    if (ACRT_FAILED(status)) {
        fprintf(stderr, "Failed to initialize runtime: %s\n",
                status.msg ? status.msg : "unknown error");
        return 1;
    }

    actor_config cfg = ACRT_ACTOR_CONFIG_DEFAULT;
    cfg.stack_size = 128 * 1024;

    actor_id runner = acrt_spawn_ex(run_all_tests, NULL, &cfg);
    if (runner == ACTOR_ID_INVALID) {
        fprintf(stderr, "Failed to spawn test runner\n");
        acrt_cleanup();
        return 1;
    }

    acrt_run();
    acrt_cleanup();

    printf("\n=== Results ===\n");
    printf("Passed: %d\n", tests_passed);
    printf("Failed: %d\n", tests_failed);
    printf("\n%s\n", tests_failed == 0 ? "All tests passed!" : "Some tests FAILED!");

    return tests_failed > 0 ? 1 : 0;
}
