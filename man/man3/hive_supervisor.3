.\" Man page for supervisor functions
.TH HIVE_SUPERVISOR 3 "January 2026" "Hive 1.0" "Actor Runtime Manual"
.SH NAME
hive_supervisor_start, hive_supervisor_stop, hive_restart_strategy_str, hive_child_restart_str \- supervisor for actor management
.SH SYNOPSIS
.nf
.B #include <hive_supervisor.h>
.PP
.BI "hive_status hive_supervisor_start(const hive_supervisor_config *" config ","
.BI "                                  const actor_config *" sup_actor_cfg ","
.BI "                                  actor_id *" out_supervisor ");"
.BI "hive_status hive_supervisor_stop(actor_id " supervisor ");"
.BI "const char *hive_restart_strategy_str(hive_restart_strategy " strategy ");"
.BI "const char *hive_child_restart_str(hive_child_restart " restart ");"
.fi
.SH DESCRIPTION
These functions implement a supervisor for managing child actors.
A supervisor monitors its children and automatically restarts them according to
configurable policies when they crash.
.SS Child Restart Types
.TP
.B HIVE_CHILD_PERMANENT
Always restart the child, regardless of exit reason.
.TP
.B HIVE_CHILD_TRANSIENT
Restart only on abnormal exit (crash). Normal exits are not restarted.
.TP
.B HIVE_CHILD_TEMPORARY
Never restart. Once the child exits, it stays dead.
.SS Restart Strategies
.TP
.B HIVE_STRATEGY_ONE_FOR_ONE
When a child crashes, only that child is restarted. Other children continue
running undisturbed. Use for independent workers.
.TP
.B HIVE_STRATEGY_ONE_FOR_ALL
When any child crashes, all children are stopped and restarted. Use when
children have strong interdependencies.
.TP
.B HIVE_STRATEGY_REST_FOR_ONE
When a child crashes, that child and all children started after it are
restarted. Children started before continue running. Use for pipelines
or sequential dependencies.
.SS Child Specification
.PP
.nf
typedef struct {
    actor_fn start;              /* Actor entry point */
    hive_actor_init_fn init;     /* Init function (NULL = skip) */
    void *init_args;             /* Arguments to init/actor */
    size_t init_args_size;       /* Size to copy (0 = pointer) */
    const char *name;            /* Child identifier for tracking */
    bool auto_register;          /* Auto-register in name registry */
    hive_child_restart restart;  /* Restart policy */
    actor_config actor_cfg;      /* Actor config */
} hive_child_spec;
.fi
.PP
.TP
.I start
The actor entry function with signature:
.nf
void start(void *args, const hive_spawn_info *siblings, size_t sibling_count)
.fi
.TP
.I init
Optional init function called in supervisor context before each child starts:
.nf
void *init(void *init_args)
.fi
The return value is passed to the actor as
.IR args .
Pass NULL to skip initialization.
.TP
.I init_args
Arguments passed to
.I init
(or directly to actor if
.I init
is NULL).
.TP
.I init_args_size
If non-zero, the argument is copied to supervisor-managed storage
(up to HIVE_MAX_MESSAGE_SIZE bytes). If zero, the pointer is passed directly.
.TP
.I name
Identifier for the child, used for logging and tracking. Must be unique among
siblings. The name is also passed to the actor in the sibling info array.
.TP
.I auto_register
If true, the child is automatically registered in the name registry at startup.
This allows other actors to find the child using
.BR hive_whereis (3).
.SS Supervisor Configuration
.PP
.nf
typedef struct {
    hive_restart_strategy strategy;  /* How to handle failures */
    uint32_t max_restarts;           /* Max restarts in period */
    uint32_t restart_period_ms;      /* Time window (ms) */
    const hive_child_spec *children; /* Child specifications */
    size_t num_children;             /* Number of children */
    void (*on_shutdown)(void *ctx);  /* Shutdown callback */
    void *shutdown_ctx;              /* Callback context */
} hive_supervisor_config;

#define HIVE_SUPERVISOR_CONFIG_DEFAULT { \\
    .strategy = HIVE_STRATEGY_ONE_FOR_ONE, \\
    .max_restarts = 3, \\
    .restart_period_ms = 5000, \\
    .children = NULL, \\
    .num_children = 0, \\
    .on_shutdown = NULL, \\
    .shutdown_ctx = NULL \\
}
.fi
.SS Two-Phase Child Start
The supervisor uses two-phase startup for children:
.IP 1. 3
All children are allocated (actor structures created)
.IP 2. 3
Sibling info array is built with all child names and IDs
.IP 3. 3
All children are started, each receiving the complete sibling array
.PP
This allows children to discover sibling actor IDs at startup without using
the name registry.
.SS Sibling Info
Each child actor receives a
.I siblings
array and
.I sibling_count
at startup. The array contains spawn info for all sibling children:
.nf
typedef struct {
    const char *name;  /* Child name (from child_spec) */
    actor_id id;       /* Actor ID */
    bool registered;   /* Whether registered in name registry */
} hive_spawn_info;
.fi
.PP
Use
.BR hive_find_sibling (3)
to find a sibling by name.
.SS Starting a Supervisor
.BR hive_supervisor_start ()
creates a new supervisor actor that immediately spawns and monitors all
specified children. The supervisor runs until stopped or until restart
intensity is exceeded.
.PP
The
.I sup_actor_cfg
parameter configures the supervisor actor itself (stack size, priority, etc.).
Pass NULL for defaults.
.SS Stopping a Supervisor
.BR hive_supervisor_stop ()
sends an asynchronous stop request to the supervisor. The supervisor will
stop all children and then exit. Use
.BR hive_monitor (3)
to be notified when shutdown completes.
.SS Restart Intensity
The supervisor tracks restart attempts within a sliding time window. If
.I max_restarts
is exceeded within
.I restart_period_ms
milliseconds, the supervisor gives up and shuts down. Set
.I max_restarts
to 0 for unlimited restarts.
.SS Utility Functions
.BR hive_restart_strategy_str ()
returns a string representation of a restart strategy
("one_for_one", "one_for_all", "rest_for_one").
.PP
.BR hive_child_restart_str ()
returns a string representation of a child restart type
("permanent", "transient", "temporary").
.SH RETURN VALUE
Functions returning
.I hive_status
indicate success when
.I status.code
is
.BR HIVE_OK .
.PP
.BR hive_restart_strategy_str ()
and
.BR hive_child_restart_str ()
return static string pointers that should not be freed.
.SH ERRORS
.TP
.B HIVE_ERR_INVALID
NULL config or out_supervisor, too many children, NULL children array with
non-zero count, NULL child function, or invalid supervisor ID.
.TP
.B HIVE_ERR_NOMEM
No supervisor slots available (see HIVE_MAX_SUPERVISORS), failed to spawn
supervisor actor, or failed to send stop message.
.TP
.B HIVE_ERR_EXISTS
A child with auto_register=true has a name that is already registered.
.SH CONFIGURATION
Supervisor limits are defined in
.IR hive_static_config.h :
.TP
.B HIVE_MAX_SUPERVISOR_CHILDREN
Maximum children per supervisor (default: 16).
.TP
.B HIVE_MAX_SUPERVISORS
Maximum concurrent supervisors (default: 8).
.SH NOTES
.SS Implementation
The supervisor is implemented as a regular actor that uses
.BR hive_monitor (3)
to watch child actors. When a monitored child dies, the supervisor receives
an EXIT message and applies the configured restart strategy.
.SS Memory
Supervisor state is allocated from a static pool (no malloc). Child arguments
are copied to fixed-size storage within the supervisor state.
.SS One Monitor Per Child
Each child consumes one entry from the global monitor pool
(HIVE_MONITOR_ENTRY_POOL_SIZE). Plan pool sizes accordingly.
.SS Shutdown Callback
The
.I on_shutdown
callback is called from the supervisor actor context just before it exits.
This can be used for cleanup or logging. The supervisor has already stopped
all children when this callback runs.
.SS Restart Semantics
.B A restarted child starts with a clean slate.
It MUST NOT assume:
.IP \(bu 2
Preserved mailbox state (mailbox is empty)
.IP \(bu 2
Preserved bus cursor position (must re-subscribe)
.IP \(bu 2
Preserved timer IDs (old timers cancelled, must create new ones)
.IP \(bu 2
Preserved actor_id (new ID assigned on restart)
.IP \(bu 2
Preserved monitor/link state (must re-establish)
.IP \(bu 2
Preserved name registration (must re-register or use auto_register)
.PP
The only state preserved across restarts is the argument passed to the child
function (copied by the supervisor at configuration time).
.SS Init Function
The init function is called again on each restart. This allows per-restart
initialization such as opening fresh file handles or resetting state.
.SS External Resources
A restarted child MUST treat all external handles as invalid and reacquire them.
This includes file descriptors, sockets, HAL handles, device state, and any
shared-memory pointers not owned by the runtime.
.PP
Failure to do so causes "works in simulation, dies on hardware" bugs because
resource lifetime is not actor lifetime.
.SS Name Registration
A supervised child intended to be discoverable has two options:
.IP \(bu 2
Set
.I auto_register = true
in the child spec (recommended for simplicity)
.IP \(bu 2
Call
.BR hive_register ()
early in the actor function
.PP
Either way, the child will be automatically unregistered when it exits.
.SS Client Rule
Actors communicating with supervised children MUST NOT cache
.I actor_id
across awaits, timeouts, or receive calls. They MUST re-resolve by name
.RB ( hive_whereis (3))
on each interaction or after any failure signal (timeout, EXIT message).
.PP
Alternatively, supervised siblings can use
.BR hive_find_sibling ()
at startup to get sibling IDs, though these IDs become stale on restart.
.PP
This prevents the classic bug: client caches ID, server restarts, client sends
to dead ID, silent failure or mysterious behavior.
.SS Restart Contract Checklist
.B On child restart, these are always reset:
.IP \(bu 2
Mailbox empty
.IP \(bu 2
Bus subscriptions gone
.IP \(bu 2
Bus cursors reset (fresh subscribe required)
.IP \(bu 2
Timers cancelled
.IP \(bu 2
Links and monitors cleared
.IP \(bu 2
actor_id changes
.IP \(bu 2
Name registration removed (must re-register or use auto_register)
.IP \(bu 2
External handles invalid (must reacquire)
.PP
.B Supervisor guarantees:
.IP \(bu 2
Restart order is deterministic: child spec order
.IP \(bu 2
Restart strategy applied exactly as defined (no hidden backoff)
.IP \(bu 2
Intensity limit is deterministic: when exceeded, supervisor shuts down, no further restarts
.IP \(bu 2
Supervisor never uses heap in hot paths; child-arg copies are bounded and static
.IP \(bu 2
Init function called again on each restart
.IP \(bu 2
Sibling array rebuilt on restart (with updated actor IDs)
.PP
.B Failure visibility:
.IP \(bu 2
Every restart attempt is observable (log)
.IP \(bu 2
Every give-up is observable (log + shutdown callback)
.SH EXAMPLE
.nf
#include <hive_runtime.h>
#include <hive_supervisor.h>
#include <stdio.h>

void worker(void *args, const hive_spawn_info *siblings,
            size_t sibling_count) {
    int id = *(int *)args;
    printf("Worker %d started (actor %u)\\n", id, hive_self());

    /* Find sibling by name */
    const hive_spawn_info *peer = hive_find_sibling(siblings,
                                                    sibling_count,
                                                    "worker-1");
    if (peer) {
        printf("Found sibling worker-1 at actor %u\\n", peer->id);
    }

    /* Do work... */

    hive_exit();
}

void on_shutdown(void *ctx) {
    printf("Supervisor shutting down\\n");
}

int main(void) {
    hive_init();

    /* Define children */
    static int ids[3] = {0, 1, 2};
    hive_child_spec children[3] = {
        {.start = worker,
         .init = NULL,
         .init_args = &ids[0],
         .init_args_size = sizeof(int),
         .name = "worker-0",
         .auto_register = false,
         .restart = HIVE_CHILD_PERMANENT,
         .actor_cfg = HIVE_ACTOR_CONFIG_DEFAULT},
        {.start = worker,
         .init = NULL,
         .init_args = &ids[1],
         .init_args_size = sizeof(int),
         .name = "worker-1",
         .auto_register = true,   /* Register in name registry */
         .restart = HIVE_CHILD_PERMANENT,
         .actor_cfg = HIVE_ACTOR_CONFIG_DEFAULT},
        {.start = worker,
         .init = NULL,
         .init_args = &ids[2],
         .init_args_size = sizeof(int),
         .name = "worker-2",
         .auto_register = false,
         .restart = HIVE_CHILD_TRANSIENT,
         .actor_cfg = HIVE_ACTOR_CONFIG_DEFAULT},
    };

    /* Configure supervisor */
    hive_supervisor_config cfg = {
        .strategy = HIVE_STRATEGY_ONE_FOR_ONE,
        .max_restarts = 5,
        .restart_period_ms = 10000,
        .children = children,
        .num_children = 3,
        .on_shutdown = on_shutdown,
    };

    /* Start supervisor */
    actor_id sup;
    hive_supervisor_start(&cfg, NULL, &sup);

    hive_run();
    hive_cleanup();
    return 0;
}
.fi
.SH SEE ALSO
.BR hive_spawn (3),
.BR hive_link (3),
.BR hive_ipc (3),
.BR hive_types (3)
