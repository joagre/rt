.\" Man page for IPC functions
.TH HIVE_IPC 3 "January 2025" "Hive 1.0" "Actor Runtime Manual"
.SH NAME
hive_ipc_notify, hive_ipc_notify_ex, hive_ipc_recv, hive_ipc_recv_match, hive_ipc_recv_matches, hive_ipc_request, hive_ipc_reply, hive_msg_is_timer, hive_ipc_pending, hive_ipc_count \- inter-process communication
.SH SYNOPSIS
.nf
.B #include <hive_ipc.h>
.PP
.BI "hive_status hive_ipc_notify(actor_id " to ", uint32_t " tag ", const void *" data ", size_t " len ");"
.BI "hive_status hive_ipc_notify_ex(actor_id " to ", hive_msg_class " class ", uint32_t " tag ","
.BI "                               const void *" data ", size_t " len ");"
.BI "hive_status hive_ipc_recv(hive_message *" msg ", int32_t " timeout_ms ");"
.BI "hive_status hive_ipc_recv_match(actor_id " from ", hive_msg_class " class ","
.BI "                            uint32_t " tag ", hive_message *" msg ", int32_t " timeout_ms ");"
.BI "hive_status hive_ipc_recv_matches(const hive_recv_filter *" filters ", size_t " num_filters ","
.BI "                            hive_message *" msg ", int32_t " timeout_ms ", size_t *" matched_index ");"
.BI "hive_status hive_ipc_request(actor_id " to ", const void *" request ", size_t " req_len ","
.BI "                         hive_message *" reply ", int32_t " timeout_ms ");"
.BI "hive_status hive_ipc_reply(const hive_message *" request ", const void *" data ", size_t " len ");"
.BI "bool hive_msg_is_timer(const hive_message *" msg ");"
.BI "bool hive_ipc_pending(void);"
.BI "size_t hive_ipc_count(void);"
.fi
.SH DESCRIPTION
These functions implement message passing between actors. Each actor has one
mailbox. Messages are asynchronous by default (fire-and-forget).
.SS Message Structure
Messages received via
.BR hive_ipc_recv ()
are stored in the
.I hive_message
structure:
.PP
.nf
typedef struct {
    actor_id       sender;  /* Sender actor ID */
    hive_msg_class class;   /* Message class */
    uint32_t       tag;     /* Message tag */
    size_t         len;     /* Payload length in bytes */
    const void    *data;    /* Payload pointer */
} hive_message;
.fi
.PP
Access payload directly via cast:
.I my_type *p = (my_type *)msg.data;
.SS Receive Filter Structure
For multi-pattern selective receive, the
.I hive_recv_filter
structure specifies matching criteria:
.PP
.nf
typedef struct {
    actor_id       sender;  /* HIVE_SENDER_ANY for any sender */
    hive_msg_class class;   /* HIVE_MSG_ANY for any class */
    uint32_t       tag;     /* HIVE_TAG_ANY for any tag */
} hive_recv_filter;
.fi
.PP
Use wildcard constants to match any value in that field.
.SS Message Classes
.TP
.B HIVE_MSG_NOTIFY
Fire-and-forget notification (sent via
.BR hive_ipc_notify ())
.TP
.B HIVE_MSG_REQUEST
Request expecting reply (sent via
.BR hive_ipc_request ())
.TP
.B HIVE_MSG_REPLY
Reply to request (sent via
.BR hive_ipc_reply ())
.TP
.B HIVE_MSG_TIMER
Timer tick (sent by runtime, see
.BR hive_timer (3))
.TP
.B HIVE_MSG_EXIT
Actor death notification (see
.BR hive_link (3))
.SS Sending Messages
.BR hive_ipc_notify ()
sends an asynchronous message to actor
.IR to
with the specified
.IR tag .
The
.I tag
parameter enables selective receive filtering on the receiver side (see
.BR hive_ipc_recv_match ()).
The payload
.I data
of length
.I len
is copied to the receiver's mailbox. The sender continues immediately without
waiting. Maximum payload size is
.B HIVE_MAX_MESSAGE_SIZE - 4
(252 bytes by default).
.PP
.BR hive_ipc_notify_ex ()
is like
.BR hive_ipc_notify ()
but allows specifying the message
.I class
and
.IR tag .
This is useful for implementing custom protocols or tagged notifications where
the receiver needs to distinguish between different message types or correlate
messages. The sender is automatically set to the current actor.
.SS Receiving Messages
.BR hive_ipc_recv ()
receives the next message from the mailbox in FIFO order. The
.I timeout_ms
parameter controls blocking behavior:
.TP
.B HIVE_TIMEOUT_NONBLOCKING (0)
Return immediately with
.B HIVE_ERR_WOULDBLOCK
if mailbox is empty.
.TP
.B HIVE_TIMEOUT_INFINITE (-1)
Block forever until a message arrives.
.TP
.B positive value
Block up to the specified milliseconds, return
.B HIVE_ERR_TIMEOUT
if exceeded.
.PP
.BR hive_ipc_recv_match ()
performs selective receive, scanning the mailbox for a message matching all
specified filter criteria. Use the wildcard constants to match any value:
.IP \(bu 2
.B HIVE_SENDER_ANY
\- match any sender
.IP \(bu 2
.B HIVE_MSG_ANY
\- match any message class
.IP \(bu 2
.B HIVE_TAG_ANY
\- match any tag
.PP
Non-matching messages are skipped but remain in the mailbox. This operation is
.BR O(n) where n is the mailbox depth.
.PP
.BR hive_ipc_recv_matches ()
performs multi-pattern selective receive, scanning the mailbox for a message
matching
.B any
of the filters in the
.I filters
array. This is useful when waiting for multiple event types (e.g., a reply OR
an exit notification, timer A OR timer B). The
.I num_filters
parameter specifies the array size. If
.I matched_index
is non-NULL, it receives the 0-based index of the filter that matched. The
same timeout semantics apply as for
.BR hive_ipc_recv ().
.PP
Example usage:
.PP
.nf
enum { FILTER_SYNC_TIMER, FILTER_LANDED };
hive_recv_filter filters[] = {
    [FILTER_SYNC_TIMER] = {HIVE_SENDER_ANY, HIVE_MSG_TIMER, sync_timer},
    [FILTER_LANDED] = {HIVE_SENDER_ANY, HIVE_MSG_NOTIFY, NOTIFY_LANDED},
};
hive_message msg;
size_t matched;
hive_ipc_recv_matches(filters, 2, &msg, -1, &matched);
if (matched == FILTER_SYNC_TIMER) { /* sync timer */ }
else { /* landed notification */ }
.fi
.SS Request/Reply Pattern
.BR hive_ipc_request ()
sends a request and blocks until a reply is received, the target dies, or
timeout expires. It:
.IP 1. 3
Sets up a temporary monitor on the target to detect death
.IP 2. 3
Generates a unique tag
.IP 3. 3
Sends message with class
.B HIVE_MSG_REQUEST
.IP 4. 3
Waits for either
.B HIVE_MSG_REPLY
with matching tag (success) or
.B HIVE_MSG_EXIT
from the monitor (target died)
.IP 5. 3
Cleans up the monitor and returns the reply, error, or
.B HIVE_ERR_CLOSED
if target died
.PP
.BR hive_ipc_reply ()
sends a reply to a received request. It extracts the sender and tag from
.I request
automatically. The
.I request
parameter must be the message received via
.BR hive_ipc_recv ().
.SS Message Inspection
.BR hive_msg_is_timer ()
returns true if
.I msg
is a timer tick message (class =
.BR HIVE_MSG_TIMER ).
.PP
.BR hive_ipc_pending ()
returns true if the mailbox contains at least one message.
.PP
.BR hive_ipc_count ()
returns the number of messages in the mailbox.
.SH RETURN VALUE
Functions returning
.I hive_status
indicate success when
.I status.code
is
.BR HIVE_OK .
.PP
.BR hive_msg_is_timer ()
returns true for timer messages, false otherwise.
.PP
.BR hive_ipc_pending ()
returns true if messages are available.
.PP
.BR hive_ipc_count ()
returns the message count.
.SH ERRORS
.TP
.B HIVE_ERR_NOMEM
IPC pool exhausted (mailbox entry pool or message data pool). Send does
.B not
block or drop messages; caller must handle this error.
.TP
.B HIVE_ERR_INVALID
Invalid actor ID, NULL data with non-zero length, or not called from actor
context.
.TP
.B HIVE_ERR_TIMEOUT
No message received within timeout period.
.TP
.B HIVE_ERR_CLOSED
Target actor died during
.BR hive_ipc_request ().
The request was sent but the target exited before sending a reply.
.TP
.B HIVE_ERR_WOULDBLOCK
Mailbox empty and timeout was
.BR HIVE_TIMEOUT_NONBLOCKING .
.SH NOTES
.SS Message Lifetime (Critical)
.B "Payload data is only valid until the next successful hive_ipc_recv() call."
Each actor has exactly one "current message" buffer. A new successful receive
overwrites the previous message data. Copy data immediately if needed later:
.PP
.nf
/* CORRECT */
hive_message msg;
hive_ipc_recv(&msg, -1);
my_data copy = *(my_data *)msg.data;  /* Copy immediately */
hive_ipc_recv(&msg, -1);              /* Previous data now invalid */
use_data(&copy);                       /* Use the copy */

/* WRONG - use-after-free */
hive_message msg;
hive_ipc_recv(&msg, -1);
my_data *ptr = (my_data *)msg.data;   /* Pointer to buffer */
hive_ipc_recv(&msg, -1);              /* Buffer overwritten! */
use_data(ptr);                         /* CRASH or corruption */
.fi
.SS Pool Exhaustion
IPC uses global pools shared by all actors:
.IP \(bu 2
.B HIVE_MAILBOX_ENTRY_POOL_SIZE
(256 default) \- mailbox entry headers
.IP \(bu 2
.B HIVE_MESSAGE_DATA_POOL_SIZE
(256 default) \- message payload buffers
.PP
When pools are exhausted,
.BR hive_ipc_notify ()
and
.BR hive_ipc_notify_ex ()
return
.B HIVE_ERR_NOMEM
immediately. They do
.B not
block or drop messages. Implement backoff-retry:
.PP
.nf
hive_status s = hive_ipc_notify(target, 0, data, len);
if (s.code == HIVE_ERR_NOMEM) {
    hive_message msg;
    hive_ipc_recv(&msg, 10);  /* Backoff 10ms */
    /* Retry or handle failure */
}
.fi
.SS Target Death During Request
If the target actor dies while
.BR hive_ipc_request ()
is waiting for a reply, and you have linked to or are monitoring the target,
an EXIT message arrives in your mailbox. Since it doesn't match the expected
REPLY, the function returns
.B HIVE_ERR_TIMEOUT
when the timeout expires. Check for EXIT messages to distinguish death from
timeout:
.PP
.nf
hive_status s = hive_ipc_request(target, &req, sizeof(req), &reply, 5000);
if (s.code == HIVE_ERR_TIMEOUT) {
    hive_message msg;
    if (hive_ipc_recv(&msg, 0).code == HIVE_OK &&
        msg.class == HIVE_MSG_EXIT) {
        hive_exit_msg *exit = (hive_exit_msg *)msg.data;
        if (exit->actor == target) {
            /* Target died */
        }
    }
}
.fi
.SS Selective Receive Performance
.BR hive_ipc_recv_match ()
scans the mailbox linearly. With deep mailboxes (100+ messages), this becomes
expensive. Keep mailboxes shallow by:
.IP \(bu 2
Processing messages promptly
.IP \(bu 2
Using
.BR hive_ipc_request ()
which provides natural backpressure
.IP \(bu 2
Avoiding patterns that queue many messages
.SS Embedded Considerations
.IP \(bu 2
Maximum message payload: 252 bytes (configurable via HIVE_MAX_MESSAGE_SIZE)
.IP \(bu 2
Zero heap allocation in IPC operations
.IP \(bu 2
O(1) allocation from static pools
.IP \(bu 2
Deterministic memory usage suitable for certification
.SH EXAMPLE
.nf
#include <hive_runtime.h>
#include <hive_ipc.h>
#include <stdio.h>

typedef struct { int x, y; } point_t;

void server(void *arg) {
    (void)arg;
    while (1) {
        hive_message msg;
        hive_ipc_recv(&msg, -1);

        if (msg.class == HIVE_MSG_REQUEST) {
            point_t *p = (point_t *)msg.data;
            int result = p->x + p->y;
            hive_ipc_reply(&msg, &result, sizeof(result));
        }
    }
}

void client(void *arg) {
    actor_id server_id = *(actor_id *)arg;

    point_t req = {10, 20};
    hive_message reply;

    hive_status s = hive_ipc_request(server_id, &req, sizeof(req),
                                     &reply, 5000);
    if (HIVE_FAILED(s)) {
        printf("Request failed: %s\\n", HIVE_ERR_STR(s));
    } else {
        int *result = (int *)reply.data;
        printf("Result: %d\\n", *result);
    }

    hive_exit();
}
.fi
.SH SEE ALSO
.BR hive_init (3),
.BR hive_spawn (3),
.BR hive_link (3),
.BR hive_timer (3),
.BR hive_types (3)
