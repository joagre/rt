.\" Man page for IPC functions
.TH ACRT_IPC 3 "January 2025" "ACRT 1.0" "Actor Runtime Manual"
.SH NAME
acrt_ipc_notify, acrt_ipc_recv, acrt_ipc_recv_match, acrt_ipc_request, acrt_ipc_reply, acrt_msg_is_timer, acrt_ipc_pending, acrt_ipc_count \- inter-process communication
.SH SYNOPSIS
.nf
.B #include <acrt_ipc.h>
.PP
.BI "acrt_status acrt_ipc_notify(actor_id " to ", const void *" data ", size_t " len ");"
.BI "acrt_status acrt_ipc_recv(acrt_message *" msg ", int32_t " timeout_ms ");"
.BI "acrt_status acrt_ipc_recv_match(const actor_id *" from ", const acrt_msg_class *" class ","
.BI "                            const uint32_t *" tag ", acrt_message *" msg ", int32_t " timeout_ms ");"
.BI "acrt_status acrt_ipc_request(actor_id " to ", const void *" request ", size_t " req_len ","
.BI "                         acrt_message *" reply ", int32_t " timeout_ms ");"
.BI "acrt_status acrt_ipc_reply(const acrt_message *" request ", const void *" data ", size_t " len ");"
.BI "bool acrt_msg_is_timer(const acrt_message *" msg ");"
.BI "bool acrt_ipc_pending(void);"
.BI "size_t acrt_ipc_count(void);"
.fi
.SH DESCRIPTION
These functions implement message passing between actors. Each actor has one
mailbox. Messages are asynchronous by default (fire-and-forget).
.SS Message Structure
Messages received via
.BR acrt_ipc_recv ()
are pre-decoded into the
.I acrt_message
structure:
.PP
.nf
typedef struct {
    actor_id       sender;  /* Sender actor ID */
    acrt_msg_class class;   /* Message class (pre-decoded) */
    uint32_t       tag;     /* Message tag (pre-decoded) */
    size_t         len;     /* Payload length in bytes */
    const void    *data;    /* Payload pointer */
} acrt_message;
.fi
.PP
Access payload directly via cast:
.I my_type *p = (my_type *)msg.data;
.SS Message Classes
.TP
.B ACRT_MSG_NOTIFY
Fire-and-forget notification (sent via
.BR acrt_ipc_notify ())
.TP
.B ACRT_MSG_REQUEST
Request expecting reply (sent via
.BR acrt_ipc_request ())
.TP
.B ACRT_MSG_REPLY
Reply to request (sent via
.BR acrt_ipc_reply ())
.TP
.B ACRT_MSG_TIMER
Timer tick (sent by runtime, see
.BR acrt_timer (3))
.TP
.B ACRT_MSG_EXIT
Actor death notification (see
.BR acrt_link (3))
.SS Sending Messages
.BR acrt_ipc_notify ()
sends an asynchronous message to actor
.IR to .
The payload
.I data
of length
.I len
is copied to the receiver's mailbox. The sender continues immediately without
waiting. Maximum payload size is
.B ACRT_MAX_MESSAGE_SIZE - 4
(252 bytes by default).
.SS Receiving Messages
.BR acrt_ipc_recv ()
receives the next message from the mailbox in FIFO order. The
.I timeout_ms
parameter controls blocking behavior:
.TP
.B ACRT_TIMEOUT_NONBLOCKING (0)
Return immediately with
.B ACRT_ERR_WOULDBLOCK
if mailbox is empty.
.TP
.B ACRT_TIMEOUT_INFINITE (-1)
Block forever until a message arrives.
.TP
.B positive value
Block up to the specified milliseconds, return
.B ACRT_ERR_TIMEOUT
if exceeded.
.PP
.BR acrt_ipc_recv_match ()
performs selective receive, scanning the mailbox for a message matching all
specified filter criteria. Pass NULL or the appropriate wildcard constant to
match any value:
.IP \(bu 2
.B ACRT_SENDER_ANY
\- match any sender
.IP \(bu 2
.B ACRT_MSG_ANY
\- match any message class
.IP \(bu 2
.B ACRT_TAG_ANY
\- match any tag
.PP
Non-matching messages are skipped but remain in the mailbox. This operation is
.BR O(n) where n is the mailbox depth.
.SS Request/Reply Pattern
.BR acrt_ipc_request ()
sends a request and blocks until a reply is received or timeout expires. It:
.IP 1. 3
Generates a unique tag
.IP 2. 3
Sends message with class
.B ACRT_MSG_REQUEST
.IP 3. 3
Blocks via
.BR acrt_ipc_recv_match ()
waiting for
.B ACRT_MSG_REPLY
with matching tag
.IP 4. 3
Returns the reply message or error
.PP
.BR acrt_ipc_reply ()
sends a reply to a received request. It extracts the sender and tag from
.I request
automatically. The
.I request
parameter must be the message received via
.BR acrt_ipc_recv ().
.SS Message Inspection
.BR acrt_msg_is_timer ()
returns true if
.I msg
is a timer tick message (class =
.BR ACRT_MSG_TIMER ).
.PP
.BR acrt_ipc_pending ()
returns true if the mailbox contains at least one message.
.PP
.BR acrt_ipc_count ()
returns the number of messages in the mailbox.
.SH RETURN VALUE
Functions returning
.I acrt_status
indicate success when
.I status.code
is
.BR ACRT_OK .
.PP
.BR acrt_msg_is_timer ()
returns true for timer messages, false otherwise.
.PP
.BR acrt_ipc_pending ()
returns true if messages are available.
.PP
.BR acrt_ipc_count ()
returns the message count.
.SH ERRORS
.TP
.B ACRT_ERR_NOMEM
IPC pool exhausted (mailbox entry pool or message data pool). Send does
.B not
block or drop messages; caller must handle this error.
.TP
.B ACRT_ERR_INVALID
Invalid actor ID, NULL data with non-zero length, or not called from actor
context.
.TP
.B ACRT_ERR_TIMEOUT
No message received within timeout period. For
.BR acrt_ipc_request (),
this includes the case where the target actor died.
.TP
.B ACRT_ERR_WOULDBLOCK
Mailbox empty and timeout was
.BR ACRT_TIMEOUT_NONBLOCKING .
.SH NOTES
.SS Message Lifetime (Critical)
.B "Payload data is only valid until the next successful acrt_ipc_recv() call."
Each actor has exactly one "current message" buffer. A new successful receive
overwrites the previous message data. Copy data immediately if needed later:
.PP
.nf
/* CORRECT */
acrt_message msg;
acrt_ipc_recv(&msg, -1);
my_data copy = *(my_data *)msg.data;  /* Copy immediately */
acrt_ipc_recv(&msg, -1);              /* Previous data now invalid */
use_data(&copy);                       /* Use the copy */

/* WRONG - use-after-free */
acrt_message msg;
acrt_ipc_recv(&msg, -1);
my_data *ptr = (my_data *)msg.data;   /* Pointer to buffer */
acrt_ipc_recv(&msg, -1);              /* Buffer overwritten! */
use_data(ptr);                         /* CRASH or corruption */
.fi
.SS Pool Exhaustion
IPC uses global pools shared by all actors:
.IP \(bu 2
.B ACRT_MAILBOX_ENTRY_POOL_SIZE
(256 default) \- mailbox entry headers
.IP \(bu 2
.B ACRT_MESSAGE_DATA_POOL_SIZE
(256 default) \- message payload buffers
.PP
When pools are exhausted,
.BR acrt_ipc_notify ()
returns
.B ACRT_ERR_NOMEM
immediately. It does
.B not
block or drop messages. Implement backoff-retry:
.PP
.nf
acrt_status s = acrt_ipc_notify(target, data, len);
if (s.code == ACRT_ERR_NOMEM) {
    acrt_message msg;
    acrt_ipc_recv(&msg, 10);  /* Backoff 10ms */
    /* Retry or handle failure */
}
.fi
.SS Target Death During Request
If the target actor dies while
.BR acrt_ipc_request ()
is waiting for a reply, and you have linked to or are monitoring the target,
an EXIT message arrives in your mailbox. Since it doesn't match the expected
REPLY, the function returns
.B ACRT_ERR_TIMEOUT
when the timeout expires. Check for EXIT messages to distinguish death from
timeout:
.PP
.nf
acrt_status s = acrt_ipc_request(target, &req, sizeof(req), &reply, 5000);
if (s.code == ACRT_ERR_TIMEOUT) {
    acrt_message msg;
    if (acrt_ipc_recv(&msg, 0).code == ACRT_OK &&
        msg.class == ACRT_MSG_EXIT) {
        acrt_exit_msg *exit = (acrt_exit_msg *)msg.data;
        if (exit->actor == target) {
            /* Target died */
        }
    }
}
.fi
.SS Selective Receive Performance
.BR acrt_ipc_recv_match ()
scans the mailbox linearly. With deep mailboxes (100+ messages), this becomes
expensive. Keep mailboxes shallow by:
.IP \(bu 2
Processing messages promptly
.IP \(bu 2
Using
.BR acrt_ipc_request ()
which provides natural backpressure
.IP \(bu 2
Avoiding patterns that queue many messages
.SS Embedded Considerations
.IP \(bu 2
Maximum message payload: 252 bytes (configurable via ACRT_MAX_MESSAGE_SIZE)
.IP \(bu 2
Zero heap allocation in IPC operations
.IP \(bu 2
O(1) allocation from static pools
.IP \(bu 2
Deterministic memory usage suitable for certification
.SH EXAMPLE
.nf
#include <acrt_runtime.h>
#include <acrt_ipc.h>
#include <stdio.h>

typedef struct { int x, y; } point_t;

void server(void *arg) {
    (void)arg;
    while (1) {
        acrt_message msg;
        acrt_ipc_recv(&msg, -1);

        if (msg.class == ACRT_MSG_REQUEST) {
            point_t *p = (point_t *)msg.data;
            int result = p->x + p->y;
            acrt_ipc_reply(&msg, &result, sizeof(result));
        }
    }
}

void client(void *arg) {
    actor_id server_id = *(actor_id *)arg;

    point_t req = {10, 20};
    acrt_message reply;

    acrt_status s = acrt_ipc_request(server_id, &req, sizeof(req),
                                     &reply, 5000);
    if (ACRT_FAILED(s)) {
        printf("Request failed: %s\\n", ACRT_ERR_STR(s));
    } else {
        int *result = (int *)reply.data;
        printf("Result: %d\\n", *result);
    }

    acrt_exit();
}
.fi
.SH SEE ALSO
.BR acrt_init (3),
.BR acrt_spawn (3),
.BR acrt_link (3),
.BR acrt_timer (3),
.BR acrt_types (3)
