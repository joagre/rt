.\" Man page for linking and monitoring functions
.TH ACRT_LINK 3 "January 2025" "ACRT 1.0" "Actor Runtime Manual"
.SH NAME
acrt_link, acrt_link_remove, acrt_monitor, acrt_monitor_cancel, acrt_is_exit_msg, acrt_exit_reason_str \- actor linking and monitoring
.SH SYNOPSIS
.nf
.B #include <acrt_link.h>
.PP
.BI "acrt_status acrt_link(actor_id " target ");"
.BI "acrt_status acrt_link_remove(actor_id " target ");"
.BI "acrt_status acrt_monitor(actor_id " target ", uint32_t *" out ");"
.BI "acrt_status acrt_monitor_cancel(uint32_t " id ");"
.BI "bool acrt_is_exit_msg(const acrt_message *" msg ");"
.BI "const char *acrt_exit_reason_str(acrt_exit_reason " reason ");"
.fi
.SH DESCRIPTION
These functions enable actors to be notified when other actors die, supporting
fault-tolerant supervisor patterns.
.SS Bidirectional Links
.BR acrt_link ()
creates a bidirectional link between the calling actor and
.IR target .
If either actor dies, the other receives an EXIT message. Links are symmetric:
if A links to B, both A and B receive notifications when the other dies.
.PP
.BR acrt_link_remove ()
removes a previously established link. Both directions are removed.
.SS Unidirectional Monitors
.BR acrt_monitor ()
creates a unidirectional monitor. The calling actor receives an EXIT message
when
.I target
dies, but not vice versa. The monitor reference is stored in
.IR out .
Multiple monitors can be created for the same target.
.PP
.BR acrt_monitor_cancel ()
cancels a monitor using the reference returned by
.BR acrt_monitor ().
.SS Exit Messages
When a linked or monitored actor dies, an EXIT message is delivered to the
mailbox with class
.BR ACRT_MSG_EXIT .
The payload is:
.PP
.nf
typedef struct {
    actor_id       actor;   /* ID of the actor that died */
    acrt_exit_reason reason;  /* Why the actor exited */
} acrt_exit_msg;
.fi
.PP
Access the exit information by casting
.IR msg.data :
.PP
.nf
if (msg.class == ACRT_MSG_EXIT) {
    acrt_exit_msg *info = (acrt_exit_msg *)msg.data;
    printf("Actor %u died: %s\\n", info->actor,
           acrt_exit_reason_str(info->reason));
}
.fi
.SS Exit Reasons
.TP
.B ACRT_EXIT_NORMAL
Actor called
.BR acrt_exit ().
.TP
.B ACRT_EXIT_CRASH
Actor function returned without calling
.BR acrt_exit ().
.TP
.B ACRT_EXIT_CRASH_STACK
Stack overflow detected (guard pattern corrupted).
.TP
.B ACRT_EXIT_KILLED
Actor was killed externally (reserved for future use).
.SS Helper Functions
.BR acrt_is_exit_msg ()
returns true if
.I msg
has class
.BR ACRT_MSG_EXIT .
.PP
.BR acrt_exit_reason_str ()
returns a human-readable string for the exit reason:
"NORMAL", "CRASH", "STACK_OVERFLOW", or "KILLED".
.SH RETURN VALUE
.BR acrt_link (),
.BR acrt_link_remove (),
.BR acrt_monitor (),
and
.BR acrt_monitor_cancel ()
return an
.I acrt_status
structure.
.PP
.BR acrt_is_exit_msg ()
returns true if the message is an exit notification.
.PP
.BR acrt_exit_reason_str ()
returns a constant string describing the exit reason.
.SH ERRORS
.TP
.B ACRT_ERR_INVALID
Cannot link/monitor self, target actor is dead or invalid, not linked to
target (for remove), or monitor reference not found (for cancel).
.TP
.B ACRT_ERR_NOMEM
Link or monitor pool exhausted (ACRT_LINK_ENTRY_POOL_SIZE or
ACRT_MONITOR_ENTRY_POOL_SIZE).
.SH NOTES
.SS Links vs Monitors
Use
.B links
for peer relationships where both parties need to know about failures (e.g.,
two cooperating actors). Use
.B monitors
for supervisor relationships where only the supervisor needs notifications
(e.g., supervisor watching workers).
.SS Supervisor Pattern
The common supervisor pattern:
.IP 1. 3
Supervisor spawns workers
.IP 2. 3
Supervisor monitors each worker
.IP 3. 3
When a worker dies, supervisor receives EXIT message
.IP 4. 3
Supervisor decides whether to restart worker, escalate, or ignore
.SS Multiple Links/Monitors
.IP \(bu 2
An actor can link to multiple other actors
.IP \(bu 2
An actor can be linked to by multiple other actors
.IP \(bu 2
Multiple monitors can exist for the same target (each has unique reference)
.IP \(bu 2
Linking to an already-linked actor returns an error
.SS Automatic Cleanup
When an actor dies:
.IP \(bu 2
All its links are removed (notifications sent to linked actors)
.IP \(bu 2
All monitors watching it receive notifications
.IP \(bu 2
All monitors it created are cancelled
.SS Pool Limits
Default pool sizes (configurable in acrt_static_config.h):
.IP \(bu 2
.B ACRT_LINK_ENTRY_POOL_SIZE
\- 128 link entries
.IP \(bu 2
.B ACRT_MONITOR_ENTRY_POOL_SIZE
\- 128 monitor entries
.SS Embedded Considerations
.IP \(bu 2
O(1) allocation from static pools
.IP \(bu 2
O(n) scan when actor dies to notify all linked/monitoring actors
.IP \(bu 2
No heap allocation
.IP \(bu 2
Deterministic behavior suitable for safety-critical systems
.SH EXAMPLE
.SS Supervisor Pattern
.nf
#include <acrt_runtime.h>
#include <acrt_link.h>
#include <acrt_ipc.h>
#include <stdio.h>

void worker(void *arg) {
    int id = *(int *)arg;
    printf("Worker %d started\\n", id);
    /* Simulate work then exit normally */
    acrt_exit();
}

void supervisor(void *arg) {
    (void)arg;
    int worker_ids[3] = {1, 2, 3};
    uint32_t monitors[3];

    /* Spawn and monitor workers */
    for (int i = 0; i < 3; i++) {
        actor_id w;
        acrt_spawn(worker, &worker_ids[i], &w);
        acrt_monitor(w, &monitors[i]);
        printf("Supervisor: monitoring worker %u\\n", w);
    }

    /* Wait for workers to exit */
    int exited = 0;
    while (exited < 3) {
        acrt_message msg;
        acrt_ipc_recv(&msg, -1);

        if (msg.class == ACRT_MSG_EXIT) {
            acrt_exit_msg *info = (acrt_exit_msg *)msg.data;
            printf("Supervisor: worker %u exited (%s)\\n",
                   info->actor, acrt_exit_reason_str(info->reason));
            exited++;

            if (info->reason != ACRT_EXIT_NORMAL) {
                /* Could restart worker here */
                printf("Supervisor: would restart crashed worker\\n");
            }
        }
    }

    printf("Supervisor: all workers done\\n");
    acrt_exit();
}

int main(void) {
    acrt_init();
    actor_id sup;
    acrt_spawn(supervisor, NULL, &sup);
    acrt_run();
    acrt_cleanup();
    return 0;
}
.fi
.SH SEE ALSO
.BR acrt_spawn (3),
.BR acrt_ipc (3),
.BR acrt_types (3)
